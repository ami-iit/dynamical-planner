/*
 * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
 * Authors: Stefano Dafarra
 * CopyPolicy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
 *
 */
#ifndef LEVI_EXPRESSIONIMPLEMENTATION_H
#define LEVI_EXPRESSIONIMPLEMENTATION_H

#include <levi/Expression.h>
#include <levi/OperatorsEvaluables.h>
#include <levi/AccessorEvaluables.h>
#include <levi/AdvancedConstructors.h>
#include <levi/SqueezeEvaluable.h>
#include <levi/Variable.h>
#include <levi/AddendsExpander.h>
#include <levi/AutogeneratedEvaluable.h>
#include <levi/MultipleSqueezedExpressions.h>
#include <levi/MultipleCompiledExpressions.h>
#include <levi/Assignable.h>

template<bool value, typename T>
static levi::ExpressionComponent<levi::ConstantEvaluable<T>> levi::build_constant(levi::bool_value<value>, const T& ) { }

template<typename T>
static levi::ExpressionComponent<levi::ConstantEvaluable<T>> levi::build_constant(levi::bool_value<true>, const T& rhs) {
    levi::ExpressionComponent<ConstantEvaluable<T>> constant(rhs);
    return constant;
}

template<typename T>
static levi::ExpressionComponent<levi::ConstantEvaluable<T>> levi::build_constant(levi::bool_value<false>, const T& rhs) {
    levi::ExpressionComponent<levi::ConstantEvaluable<T>> constant(rhs, "UnnamedMatrix");
    return constant;
}

template<int rowsNumber, class EvaluableT>
levi::ExpressionComponent<typename levi::ConstructorByRows<EvaluableT, rowsNumber>::composite_evaluable>
levi::ComposeByRows(const std::vector<ExpressionComponent<EvaluableT>>& rows, const std::string& name)
{
    static_assert (EvaluableT::rows_at_compile_time == 1, "ComposeByRows can compose only from expressions which have 1 row at compile time.");
    return levi::ExpressionComponent<levi::ConstructorByRows<EvaluableT, rowsNumber>>(rows, name);
}

template<int colsNumber, typename EvaluableT>
levi::ExpressionComponent<typename levi::ConstructorByCols<EvaluableT, colsNumber>::composite_evaluable>
levi::ComposeByCols(const std::vector<levi::ExpressionComponent<EvaluableT>>& cols, const std::string& name)
{
    static_assert (EvaluableT::cols_at_compile_time == 1, "ComposeByCols can compose only from expressions which have 1 col at compile time.");
    return levi::ExpressionComponent<levi::ConstructorByCols<EvaluableT, colsNumber>>(cols, name);
}

template <typename Matrix>
levi::MultipleCompiledOutputPointer<Matrix> levi::CompileMultipleExpressions(const levi::MultipleExpressionsMap<Matrix> &elements, const std::string& name) {
    return std::make_unique<levi::MultipleCompiledExpressions<levi::Evaluable<Matrix>>>(elements, name);
}

template <typename Matrix>
levi::MultipleSqueezedOutputPointer<Matrix> levi::SqueezeMultipleExpressions(const levi::MultipleExpressionsMap<Matrix> &elements) {
    return std::make_unique<levi::MultipleSqueezedExpressions<levi::Evaluable<Matrix>>>(elements);
}

template<typename LeftEvaluable, typename RightEvaluable>
levi::ExpressionComponent<levi::Evaluable<Eigen::Matrix<typename levi::scalar_product_return<typename LeftEvaluable::value_type,
                                                                                             typename RightEvaluable::value_type>::type,
                                                        LeftEvaluable::rows_at_compile_time, Eigen::Dynamic>>>
levi::MatrixProductDerivativeExpression(const levi::ExpressionComponent<LeftEvaluable>& lhs, const levi::ExpressionComponent<RightEvaluable>& rhs, std::shared_ptr<levi::VariableBase> variable) {
    return levi::ExpressionComponent<levi::MatrixProductDerivative<LeftEvaluable, RightEvaluable>>(lhs, rhs, variable);
}

template <class EvaluableT>
template<bool value>
void levi::ExpressionComponent<EvaluableT>::default_constructor(levi::bool_value<value>)
{ }

template <class EvaluableT>
void levi::ExpressionComponent<EvaluableT>::default_constructor(levi::bool_value<true>) {
    m_evaluable = std::make_shared<EvaluableT>();
    m_callerID = m_evaluable->getNewCallerID();
}

template <class EvaluableT>
void levi::ExpressionComponent<EvaluableT>::default_constructor(levi::bool_value<false>) {
    m_evaluable = nullptr;
}

template <class EvaluableT>
template<bool value, typename OtherEvaluable>
void levi::ExpressionComponent<EvaluableT>::casted_assignement(levi::bool_value<value>, const levi::ExpressionComponent<OtherEvaluable>&) {}

template <class EvaluableT>
template<typename OtherEvaluable>
void levi::ExpressionComponent<EvaluableT>::casted_assignement(levi::bool_value<true>, const levi::ExpressionComponent<OtherEvaluable>& other) {
    m_evaluable = other.m_evaluable;
    m_callerID = m_evaluable->getNewCallerID();
}

template <class EvaluableT>
template<typename OtherEvaluable>
void levi::ExpressionComponent<EvaluableT>::casted_assignement(levi::bool_value<false>, const levi::ExpressionComponent<OtherEvaluable>& other) {
    static_assert (!(std::is_base_of<levi::VariableBase, EvaluableT>::value && !std::is_base_of<levi::VariableBase, OtherEvaluable>::value),
                  "Cannot cast an expression to a variable. Try to use the asVariable() method.");
    m_evaluable = std::make_shared<levi::CastEvaluable<EvaluableT, OtherEvaluable>>(other);
    m_callerID = m_evaluable->getNewCallerID();
}

template <class EvaluableT>
template <typename EvaluableOut>
levi::ExpressionComponent<EvaluableOut> levi::ExpressionComponent<EvaluableT>::return_this(levi::bool_value<true>) const {
    return *this;
}

template <class EvaluableT>
template <typename EvaluableOut>
levi::ExpressionComponent<EvaluableOut> levi::ExpressionComponent<EvaluableT>::return_this(levi::bool_value<false>) const {
    return levi::ExpressionComponent<EvaluableOut>();
}

template <class EvaluableT>
template<typename EvaluableOut, typename EvaluableRhs>
levi::ExpressionComponent<EvaluableOut> levi::ExpressionComponent<EvaluableT>::return_rhs(levi::bool_value<true>,
                                                                                          const levi::ExpressionComponent<EvaluableRhs>& rhs) const {
    return rhs;
}

template <class EvaluableT>
template<typename EvaluableOut, typename EvaluableRhs>
levi::ExpressionComponent<EvaluableOut> levi::ExpressionComponent<EvaluableT>::return_rhs(levi::bool_value<false>,
                                                                                          const levi::ExpressionComponent<EvaluableRhs>& rhs) const {
    levi::unused(rhs);
    return levi::ExpressionComponent<EvaluableOut>();
}

template <class EvaluableT>
template<typename EvaluableRhs>
levi::ExpressionComponent<levi::ProductOutputEvaluable<EvaluableT, EvaluableRhs>> levi::ExpressionComponent<EvaluableT>::commute_factors(levi::bool_value<true>, const levi::ExpressionComponent<EvaluableRhs>& rhs) const {
    return levi::ExpressionComponent<levi::ProductEvaluable<levi::Evaluable<typename EvaluableRhs::value_type>, EvaluableT>>(rhs(0,0), *this);
}

template <class EvaluableT>
template<typename EvaluableRhs>
levi::ExpressionComponent<levi::ProductOutputEvaluable<EvaluableT, EvaluableRhs>> levi::ExpressionComponent<EvaluableT>::commute_factors(levi::bool_value<false>, const levi::ExpressionComponent<EvaluableRhs>& rhs) const {
    assert(false && "Trying to commute evaluables that cannot be commuted.");
    return levi::ExpressionComponent<levi::ProductEvaluable<EvaluableT, EvaluableRhs>>(*this, rhs);
}

template <class EvaluableT>
levi::ExpressionComponent<EvaluableT>::ExpressionComponent()
    : m_isNull(std::is_same<EvaluableT, levi::NullEvaluable<typename EvaluableT::matrix_type>>::value)
      , m_isIdentity(std::is_same<EvaluableT, levi::IdentityEvaluable<typename EvaluableT::matrix_type>>::value)
{
    default_constructor(levi::bool_value<std::is_constructible<EvaluableT>::value>());
}

template <class EvaluableT>
template<class EvaluableOther, typename>
levi::ExpressionComponent<EvaluableT>::ExpressionComponent(const ExpressionComponent<EvaluableOther>& other) {

    m_isNull = other.m_isNull;
    m_isIdentity = other.m_isIdentity;
    if (other.isValidExpression()) {
        casted_assignement(levi::bool_value<std::is_base_of<EvaluableT, EvaluableOther>::value>(), other);
    } else {
        m_evaluable = nullptr;
    }
}

template <class EvaluableT>
levi::ExpressionComponent<EvaluableT>::ExpressionComponent(const ExpressionComponent<EvaluableT>& other) {
    m_isNull = other.m_isNull;
    m_isIdentity = other.m_isIdentity;
    m_evaluable = other.m_evaluable;
    if (m_evaluable) {
        m_callerID = m_evaluable->getNewCallerID();
    }
}

template <class EvaluableT>
template<class EvaluableOther, typename>
levi::ExpressionComponent<EvaluableT>::ExpressionComponent(ExpressionComponent<EvaluableOther>&& other) {

    m_isNull = other.m_isNull;
    m_isIdentity = other.m_isIdentity;
    if (other.isValidExpression()) {
        casted_assignement(levi::bool_value<std::is_base_of<EvaluableT, EvaluableOther>::value>(), other);
    } else {
        m_evaluable = nullptr;
    }
}

template <class EvaluableT>
levi::ExpressionComponent<EvaluableT>::ExpressionComponent(ExpressionComponent<EvaluableT>&& other) {
    m_isNull = other.m_isNull;
    m_isIdentity = other.m_isIdentity;
    m_evaluable = other.m_evaluable;
    if (m_evaluable) {
        m_callerID = m_evaluable->getNewCallerID();
    }
}

template <class EvaluableT>
template<class... Args, typename>
levi::ExpressionComponent<EvaluableT>::ExpressionComponent(Args&&... args)
    : m_evaluable(std::make_shared<EvaluableT>(std::forward<Args>(args)...))
    , m_isNull(std::is_same<EvaluableT, levi::NullEvaluable<typename EvaluableT::matrix_type>>::value)
{
    m_isIdentity = (std::is_same<EvaluableT, levi::IdentityEvaluable<typename EvaluableT::matrix_type>>::value) && (rows() == cols());
    m_callerID = m_evaluable->getNewCallerID();
}

template<class EvaluableT>
levi::ExpressionComponent<EvaluableT>::~ExpressionComponent()
{
    if (m_evaluable) {
        m_evaluable->deleteID(m_callerID);
    }
}

template <class EvaluableT>
std::weak_ptr<EvaluableT> levi::ExpressionComponent<EvaluableT>::evaluable() const {
    return m_evaluable;
}

template <class EvaluableT>
std::string levi::ExpressionComponent<EvaluableT>::name() const {
    assert(m_evaluable && "This expression is empty.");
    return m_evaluable->name();
}

template <class EvaluableT>
Eigen::Index levi::ExpressionComponent<EvaluableT>::rows() const {
    assert(m_evaluable && "This expression is empty.");
    return m_evaluable->rows();
}

template <class EvaluableT>
Eigen::Index levi::ExpressionComponent<EvaluableT>::cols() const {
    assert(m_evaluable && "This expression is empty.");
    return m_evaluable->cols();
}

template <class EvaluableT>
bool levi::ExpressionComponent<EvaluableT>::isNew() const {
    if (!m_evaluable)
        return false;

    return m_evaluable->isNew(m_callerID);
}

template <class EvaluableT>
bool levi::ExpressionComponent<EvaluableT>::isNull() const {
    if (!m_evaluable)
        return true;

    return m_isNull;
}

template <class EvaluableT>
const typename EvaluableT::EvaluableInfo& levi::ExpressionComponent<EvaluableT>::info() const {
    assert(m_evaluable && "Cannot get infos from this expression.");
    return m_evaluable->info();
}


template <class EvaluableT>
const typename EvaluableT::matrix_type &levi::ExpressionComponent<EvaluableT>::evaluate() {
    assert(m_evaluable && "This expression is empty.");
    return m_evaluable->evaluateID(m_callerID);
}

template <class EvaluableT>
template<class EvaluableRhs>
levi::ExpressionComponent<levi::Evaluable<typename levi::matrix_sum_return<typename EvaluableT::matrix_type, typename EvaluableRhs::matrix_type>::type>> levi::ExpressionComponent<EvaluableT>::operator+(const levi::ExpressionComponent<EvaluableRhs>& rhs) const {
    assert(rows() == rhs.rows());
    assert(cols() == rhs.cols());
    assert(m_evaluable && "This expression is empty.");
    assert(rhs.m_evaluable);

    if (m_isNull) {
        return rhs;
    }

    if (rhs.m_isNull) {
        return *this;
    }

    if ((m_isIdentity && rhs.m_isIdentity) || (operator==(rhs))) {
        return 2.0 * rhs;
    }

    if (info().type == levi::EvaluableType::InvertedSign) {
        levi::ExpressionComponent<typename EvaluableT::EvaluableInfo::operands_evaluable> castedRhs = rhs;
        return castedRhs - (info().lhs);
    }

    if (rhs.info().type == levi::EvaluableType::InvertedSign) {
        levi::ExpressionComponent<typename EvaluableT::EvaluableInfo::operands_evaluable> castedLhs = *this;
        return castedLhs - rhs.info().lhs;
    }

    levi::AddendsExpander<EvaluableT> expander(*this, rhs);

    if (expander.lhs().isValidExpression()) {
        if (expander.rhs().isValidExpression()) {
            return levi::ExpressionComponent<levi::SumEvaluable<typename EvaluableT::EvaluableInfo::operands_evaluable, typename EvaluableT::EvaluableInfo::operands_evaluable>>(expander.lhs(), expander.rhs());
        } else {
            return expander.lhs();
        }
    }

    return levi::ExpressionComponent<levi::SumEvaluable<EvaluableT, EvaluableRhs>>(*this, rhs);
}

template <class EvaluableT>
template <typename Matrix>
levi::ExpressionComponent<levi::Evaluable<typename levi::matrix_sum_return<typename EvaluableT::matrix_type, Matrix>::type>> levi::ExpressionComponent<EvaluableT>::operator+(const Matrix& rhs) const {
    levi::ExpressionComponent<levi::ConstantEvaluable<Matrix>> constant = levi::build_constant(levi::bool_value<std::is_arithmetic<Matrix>::value>(), rhs);

    return operator+(constant);
}

template <class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<typename EvaluableT::matrix_type>> levi::ExpressionComponent<EvaluableT>::operator+() const {
    return *this;
}


template <class EvaluableT>
template<class EvaluableRhs>
levi::ExpressionComponent<levi::Evaluable<typename levi::matrix_sum_return<typename EvaluableT::matrix_type, typename EvaluableRhs::matrix_type>::type>> levi::ExpressionComponent<EvaluableT>::operator-(const levi::ExpressionComponent<EvaluableRhs>& rhs) const {
    assert(rows() == rhs.rows());
    assert(cols() == rhs.cols());
    assert(m_evaluable && "This expression is empty.");
    assert(rhs.m_evaluable);

    if (m_isNull) {
        return -rhs;
    }

    if (rhs.m_isNull) {
        return *this;
    }

    if ((m_isIdentity && rhs.m_isIdentity) || (operator==(rhs))) {
        return levi::ExpressionComponent<levi::NullEvaluable<typename levi::matrix_sum_return<typename EvaluableT::matrix_type, typename EvaluableRhs::matrix_type>::type>>(rows(), cols());
    }

    if (info().type == levi::EvaluableType::InvertedSign) {
        levi::ExpressionComponent<typename EvaluableT::EvaluableInfo::operands_evaluable> castedRhs = rhs;
        return -(info().lhs + castedRhs);
    }

    if (rhs.info().type == levi::EvaluableType::InvertedSign) {
        levi::ExpressionComponent<typename EvaluableT::EvaluableInfo::operands_evaluable> castedLhs = *this;
        return castedLhs + rhs.info().lhs;
    }

    levi::AddendsExpander<EvaluableT> expander(*this, rhs, -1);

    if (expander.lhs().isValidExpression()) {
        if (expander.rhs().isValidExpression()) {
            return levi::ExpressionComponent<levi::SumEvaluable<typename EvaluableT::EvaluableInfo::operands_evaluable, typename EvaluableT::EvaluableInfo::operands_evaluable>>(expander.lhs(), expander.rhs());
        } else {
            return expander.lhs();
        }
    }

    return levi::ExpressionComponent<levi::SubtractionEvaluable<EvaluableT, EvaluableRhs>>(*this, rhs);
}

template <class EvaluableT>
template <typename Matrix>
levi::ExpressionComponent<levi::Evaluable<typename levi::matrix_sum_return<typename EvaluableT::matrix_type, Matrix>::type>> levi::ExpressionComponent<EvaluableT>::operator-(const Matrix& rhs) const {
    levi::ExpressionComponent<levi::ConstantEvaluable<Matrix>> constant = levi::build_constant(levi::bool_value<std::is_arithmetic<Matrix>::value>(), rhs);

    return operator-(constant);
}

template<class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<typename EvaluableT::matrix_type>> levi::ExpressionComponent<EvaluableT>::operator-() const
{
    assert(m_evaluable && "This expression is empty.");
    levi::ExpressionComponent<levi::Evaluable<typename EvaluableT::matrix_type>> newExpression;

    if (m_isNull) {
        return *this;
    }

    if (info().type == levi::EvaluableType::InvertedSign) {
        return info().lhs;
    }

    newExpression = levi::ExpressionComponent<levi::SignInvertedEvaluable<EvaluableT>>(*this, 0);

    return newExpression;
}

template <class EvaluableT>
template<class EvaluableRhs>
levi::ExpressionComponent<levi::Evaluable<typename levi::matrix_product_return<typename EvaluableT::matrix_type, typename EvaluableRhs::matrix_type>::type>> levi::ExpressionComponent<EvaluableT>::operator*(const levi::ExpressionComponent<EvaluableRhs>& rhs) const {
    assert((cols() == 1 && rows() == 1) || (rhs.cols() == 1 && rhs.rows() == 1) || (cols() == rhs.rows()) && "Dimension mismatch for product.");
    assert(m_evaluable && "This expression is empty.");
    assert(rhs.m_evaluable);

    if (m_isNull || rhs.m_isNull) {
        return levi::ExpressionComponent<levi::NullEvaluable<typename levi::matrix_product_return<typename EvaluableT::matrix_type, typename EvaluableRhs::matrix_type>::type>>((rows() == 1 && cols() == 1 && rhs.rows() != 1)? rhs.rows() : rows(),
                                                                                                                                                                                (rhs.rows() == 1 && rhs.cols() == 1 && cols() != 1)? cols() : rhs.cols());
    }

    typedef levi::Evaluable<typename levi::matrix_product_return<typename EvaluableT::matrix_type, typename EvaluableRhs::matrix_type>::type> return_evaluable;

    if (rhs.m_isIdentity && (rhs.rows() == rhs.cols()) && ((rhs.rows() == 1) || (cols() == rhs.rows()))) { //i.e. it's not the case of scalar * I
        return return_this<return_evaluable>(bool_value<(((return_evaluable::rows_at_compile_time == EvaluableT::rows_at_compile_time) ||
                                                          (return_evaluable::rows_at_compile_time * EvaluableT::rows_at_compile_time < 0)) &&
                                                         ((return_evaluable::cols_at_compile_time == EvaluableT::cols_at_compile_time) ||
                                                          (return_evaluable::cols_at_compile_time * EvaluableT::cols_at_compile_time < 0)))>());
    }

    if (m_isIdentity && (rows() == cols()) && ((rows() == 1) || (cols() == rhs.rows()))) {
        return return_rhs<return_evaluable>(bool_value<(((return_evaluable::rows_at_compile_time == EvaluableRhs::rows_at_compile_time) ||
                                                         (return_evaluable::rows_at_compile_time * EvaluableRhs::rows_at_compile_time < 0)) &&
                                                        ((return_evaluable::cols_at_compile_time == EvaluableRhs::cols_at_compile_time) ||
                                                         (return_evaluable::cols_at_compile_time * EvaluableRhs::cols_at_compile_time < 0)))>(), rhs);
    }

    auto lhs = *this;

    if (info().type == levi::EvaluableType::InvertedSign) {
        levi::ExpressionComponent<typename EvaluableT::EvaluableInfo::operands_evaluable> castedRhs = rhs;
        return -(info().lhs * rhs);
    }

    if (rhs.info().type == levi::EvaluableType::InvertedSign) {
        levi::ExpressionComponent<typename EvaluableT::EvaluableInfo::operands_evaluable> castedLhs = lhs;
        return -(castedLhs * rhs.info().lhs);
    }

    using rhsOperand = typename EvaluableRhs::EvaluableInfo::operands_evaluable;
    using lhsOperand = typename EvaluableT::EvaluableInfo::operands_evaluable;

    bool isLhsScalar = (lhs.rows() == 1) && (lhs.cols() == 1);
    bool isRhsScalar = (rhs.rows() == 1) && (rhs.cols() == 1);
    bool isLhsProduct = lhs.info().type == levi::EvaluableType::Product;
    bool isRhsProduct = rhs.info().type == levi::EvaluableType::Product;
    levi::ExpressionComponent<lhsOperand> lhs_lhs = lhs.info().lhs;
    levi::ExpressionComponent<lhsOperand> lhs_rhs = lhs.info().rhs;
    levi::ExpressionComponent<rhsOperand> rhs_lhs = rhs.info().lhs;
    levi::ExpressionComponent<rhsOperand> rhs_rhs = rhs.info().rhs;
    bool isLhsLhsScalar;
    bool isRhsLhsScalar;

    if (lhs_lhs.isValidExpression()) {
        isLhsLhsScalar = (lhs_lhs.rows() == 1) && (lhs_lhs.cols() == 1);
    } else {
        isLhsLhsScalar = false;
    }

    if (rhs_lhs.isValidExpression()) {
        isRhsLhsScalar = (rhs_lhs.rows() == 1) && (rhs_lhs.cols() == 1);
    } else {
        isRhsLhsScalar = false;
    }

    auto costOfProduct = [](Eigen::Index lhsRows, Eigen::Index lhsCols, Eigen::Index rhsCols){return lhsRows * rhsCols * (3 * lhsCols - 1);}; //assuming the cost of product being twice the one of sums.
    auto threeMatricesCompositionCost = [costOfProduct](Eigen::Index leftmostRows, Eigen::Index leftmostCols, Eigen::Index rightmostRows, Eigen::Index rightmostCols) -> std::pair<Eigen::Index, Eigen::Index>{
        Eigen::Index composeLeft = costOfProduct(leftmostRows, leftmostCols, rightmostRows); //1*2
        composeLeft += costOfProduct(leftmostRows, rightmostRows, rightmostCols); // (1*2)*3

        Eigen::Index composeRight = costOfProduct(leftmostCols, rightmostRows, rightmostCols); // 2*3
        composeRight += costOfProduct(leftmostRows, leftmostCols, rightmostCols); //1*(2*3)

        return std::make_pair(composeLeft, composeRight);
    }; //Cost of composing three matrices, either on the left or on the right (the middle one dimensions are obtained from lhs and rhs)


    if (isLhsScalar) {
        if (isRhsScalar) {
            return levi::ExpressionComponent<levi::ProductEvaluable<levi::Evaluable<typename EvaluableT::value_type>, levi::Evaluable<typename EvaluableRhs::value_type>>>(lhs(0,0), rhs(0,0));
        } else {
            if (isRhsProduct) {
                if (isRhsLhsScalar) {
                    // scalar1 * (scalar2 * rhs)
                    using newLhsType = levi::ProductOutputEvaluable<levi::Evaluable<typename EvaluableT::value_type>, levi::Evaluable<typename rhsOperand::value_type>>;
                    return levi::ExpressionComponent<levi::ProductEvaluable<newLhsType, rhsOperand>>(lhs(0,0) * rhs_lhs(0,0), rhs_rhs);
                } else {
                    // scalar * (lhs * rhs)
                    using newLhsType = levi::ProductOutputEvaluable<levi::Evaluable<typename EvaluableT::value_type>, rhsOperand>;
                    return levi::ExpressionComponent<levi::ProductEvaluable<newLhsType, rhsOperand>>(lhs(0,0) * rhs_lhs, rhs_rhs);
                }
            } else {
                //scalar * matrix
                return levi::ExpressionComponent<levi::ProductEvaluable<levi::Evaluable<typename EvaluableT::value_type>, EvaluableRhs>>(lhs(0, 0), rhs);
            }
        }
    } else {
        if (isLhsProduct) {
            if (isRhsScalar) {
                if (isLhsLhsScalar) {
                    //(scalar1 * rhs) * scalar
                    using newLhsType = levi::ProductOutputEvaluable<levi::Evaluable<typename lhsOperand::value_type>, levi::Evaluable<typename EvaluableRhs::value_type>>;
                    return levi::ExpressionComponent<levi::ProductEvaluable<newLhsType, lhsOperand>>(lhs_lhs(0,0) * rhs(0,0), lhs_rhs);
                } else {
                    //(lhs * rhs) * scalar
                    using newLhsType = levi::ProductOutputEvaluable<lhsOperand, levi::Evaluable<typename EvaluableRhs::value_type>>;
                    return levi::ExpressionComponent<levi::ProductEvaluable<newLhsType, lhsOperand>>(rhs(0,0) * lhs_lhs, lhs_rhs);
                }
            } else {
                if (isRhsProduct) {
                    if (isLhsLhsScalar) {
                        if (isRhsLhsScalar) {
                            //(scalar1 * rhs1) * (scalar2 * rhs2)
                            using newLhsType = levi::ProductOutputEvaluable<levi::Evaluable<typename lhsOperand::value_type>, levi::Evaluable<typename rhsOperand::value_type>>;
                            using newRhsType = levi::ProductOutputEvaluable<lhsOperand, rhsOperand>;
                            return levi::ExpressionComponent<levi::ProductEvaluable<newLhsType, newRhsType>>(lhs_lhs(0,0) * rhs_lhs(0,0), lhs_rhs*rhs_rhs);
                        } else {
                            //(scalar * rhs1) * (lhs2 * rhs2)
                            using newRhsType = levi::ProductOutputEvaluable<lhsOperand, EvaluableRhs>;
                            return levi::ExpressionComponent<levi::ProductEvaluable<levi::Evaluable<typename lhsOperand::value_type>, newRhsType>>(lhs_lhs(0, 0), lhs_rhs * rhs);
                        }
                    } else {
                        if (isRhsLhsScalar) {
                            //(lhs1 * rhs1) * (scalar * rhs2)
                            using newRhsType = levi::ProductOutputEvaluable<EvaluableT, rhsOperand>;
                            return levi::ExpressionComponent<levi::ProductEvaluable<levi::Evaluable<typename rhsOperand::value_type>, newRhsType>>(rhs_lhs(0, 0), lhs * rhs_rhs);
                        } else {
                            //(lhs1 * rhs1) * (lhs2 * rhs2)

                            auto leftCompositionCosts = threeMatricesCompositionCost(lhs_lhs.rows(), lhs_lhs.cols(), rhs_lhs.rows(), rhs_lhs.cols());

                            Eigen::Index costLeft = std::min(leftCompositionCosts.first, leftCompositionCosts.second);
                            costLeft += costOfProduct(lhs_lhs.rows(), rhs_rhs.rows(), rhs_rhs.cols());

                            Eigen::Index costMiddle = costOfProduct(lhs_lhs.rows(), lhs_lhs.cols(), lhs_rhs.cols()) + costOfProduct(rhs_lhs.rows(), rhs_lhs.cols(), rhs_rhs.cols());

                            auto rightCompositionCosts = threeMatricesCompositionCost(lhs_rhs.rows(), lhs_rhs.cols(), rhs_rhs.rows(), rhs_rhs.cols());
                            Eigen::Index costRight = std::min(rightCompositionCosts.first, rightCompositionCosts.second);
                            costRight += costOfProduct(lhs_lhs.rows(), lhs_lhs.cols(), lhs_rhs.rows());

                            if (costLeft < std::min(costMiddle, costRight)) {
                                using newLhsType = levi::ProductOutputEvaluable<EvaluableT, rhsOperand>;

                                return levi::ExpressionComponent<levi::ProductEvaluable<newLhsType, rhsOperand>>(lhs * rhs_lhs, rhs_rhs); //(lhs1 * rhs1 * lhs2) * rhs2
                            } else if (costRight < std::min(costMiddle, costLeft)) {
                                using newRhsType = levi::ProductOutputEvaluable<lhsOperand, EvaluableRhs>;

                                return levi::ExpressionComponent<levi::ProductEvaluable<lhsOperand, newRhsType>>(lhs_lhs, lhs_rhs * rhs); //lhs1 * (rhs1 * lhs2 * rhs2)
                            } else {
                                return levi::ExpressionComponent<levi::ProductEvaluable<EvaluableT, EvaluableRhs>>(lhs, rhs); //(lhs1 * rhs1) * (lhs2 * rhs2)
                            }
                        }
                    }
                } else {
                    if (isLhsLhsScalar) {
                        //(scalar * rhs) * matrix
                        using newRhsType = levi::ProductOutputEvaluable<lhsOperand, EvaluableRhs>;
                        return levi::ExpressionComponent<levi::ProductEvaluable<levi::Evaluable<typename lhsOperand::value_type>, newRhsType>>(lhs_lhs(0,0), lhs_rhs * rhs);
                    } else {
                        //(lhs * rhs) * matrix
                        auto compositionCost = threeMatricesCompositionCost(lhs_lhs.rows(), lhs_lhs.cols(), rhs.rows(), rhs.cols());
                        if (compositionCost.second < compositionCost.first) {
                            using newRhsType = levi::ProductOutputEvaluable<lhsOperand, EvaluableRhs>;
                            return levi::ExpressionComponent<levi::ProductEvaluable<lhsOperand, newRhsType>>(lhs_lhs, lhs_rhs * rhs);  //lhs * (rhs * matrix)
                        } else {
                            return levi::ExpressionComponent<levi::ProductEvaluable<EvaluableT, EvaluableRhs>>(lhs, rhs); //(lhs * rhs) * matrix

                        }
                    }
                }
            }
        } else {
            if (isRhsScalar) {
                //matrix * scalar -> keep the scalar on the left hand side
                return commute_factors(levi::bool_value<levi::are_commutable<EvaluableT, EvaluableRhs>::value>(), rhs);
            } else {
                if (isRhsProduct) {
                    if (isRhsLhsScalar) {
                        //matrix * (scalar * rhs)
                        using newRhsType = levi::ProductOutputEvaluable<EvaluableT, rhsOperand>;
                        return levi::ExpressionComponent<levi::ProductEvaluable<levi::Evaluable<typename rhsOperand::value_type>, newRhsType>>(rhs_lhs(0,0), lhs * rhs_rhs);
                    } else {
                        //matrix * (lhs * rhs)
                        auto compositionCost = threeMatricesCompositionCost(lhs.rows(), lhs.cols(), rhs_rhs.rows(), rhs_rhs.cols());

                        if (compositionCost.first < compositionCost.second) {
                            using newLhsType = levi::ProductOutputEvaluable<EvaluableT, rhsOperand>;

                            return levi::ExpressionComponent<levi::ProductEvaluable<newLhsType, rhsOperand>>(lhs * rhs_lhs, rhs_rhs); //(matrix * lhs) * rhs

                        } else {
                            return levi::ExpressionComponent<levi::ProductEvaluable<EvaluableT, EvaluableRhs>>(lhs, rhs); //matrix * (lhs * rhs)
                        }
                    }
                } else {
                    //matrix * matrix
                    return levi::ExpressionComponent<levi::ProductEvaluable<EvaluableT, EvaluableRhs>>(lhs, rhs);
                }
            }
        }
    }
}

template <class EvaluableT>
template <typename Matrix>
levi::ExpressionComponent<levi::Evaluable<typename levi::matrix_product_return<typename EvaluableT::matrix_type, Matrix>::type>> levi::ExpressionComponent<EvaluableT>::operator*(const Matrix& rhs) const {
    levi::ExpressionComponent<levi::ConstantEvaluable<Matrix>> constant = levi::build_constant(levi::bool_value<std::is_arithmetic<Matrix>::value>(), rhs);

    return operator*(constant);
}

template <class EvaluableT>
template<class EvaluableRhs>
levi::ExpressionComponent<levi::Evaluable<typename levi::matrix_product_return<typename EvaluableT::matrix_type, typename EvaluableRhs::value_type>::type>>
levi::ExpressionComponent<EvaluableT>::operator/(const levi::ExpressionComponent<EvaluableRhs> &rhs) const
{
    static_assert ((EvaluableRhs::rows_at_compile_time == Eigen::Dynamic || EvaluableRhs::rows_at_compile_time == 1) && (EvaluableRhs::cols_at_compile_time == Eigen::Dynamic || EvaluableRhs::cols_at_compile_time == 1),
                   "The operator/ can be used only when the rhs is a scalar or a 1x1 matrix.");

    assert(rhs.rows() == 1 && rhs.cols() == 1 && "The operator/ can be used only when the rhs is a scalar or a 1x1 matrix.");
    assert(m_evaluable && "This expression is empty.");
    assert(rhs.m_evaluable);

    return levi::ExpressionComponent<levi::DivisionEvaluable<EvaluableT, EvaluableRhs>>(*this, rhs);
}

template <class EvaluableT>
template<typename Scalar>
levi::ExpressionComponent<levi::Evaluable<typename levi::matrix_product_return<typename EvaluableT::matrix_type, Scalar>::type>> levi::ExpressionComponent<EvaluableT>::operator/(const Scalar &rhs) const
{
    static_assert (std::is_arithmetic<Scalar>::value, "The rhs has to be a scalar.");
    assert(m_evaluable && "This expression is empty.");

    levi::ExpressionComponent<levi::ConstantEvaluable<Scalar>> constant(rhs);

    return operator/(constant);
}

template <class EvaluableT>
template <typename EvaluableRhs>
bool levi::ExpressionComponent<EvaluableT>::operator==(const levi::ExpressionComponent<EvaluableRhs>& other) const {
    assert(m_evaluable && "This expression is empty.");
    assert(other.isValidExpression() && "The other expression is empty.");

    if (info().hash == other.info().hash) {
        return true;
    } else if (info().type == other.info().type ) {
        using Type = levi::EvaluableType;
        Type type = info().type;

        if (type == Type::Sum) {
            return ((info().lhs == other.info().lhs) && (info().rhs == other.info().rhs)) || ((info().lhs == other.info().rhs) && (info().rhs == other.info().lhs));
        } else if (type == Type::Subtraction || type == Type::Product || type == Type::Division || type == Type::Horzcat || type == Type::Vertcat) {
            return (info().lhs == other.info().lhs) && (info().rhs == other.info().rhs);
        } else if (type == Type::InvertedSign || type == Type::Transpose) {
            return info().lhs == other.info().lhs;
        } else if (type == Type::Pow) {
            return (info().lhs == other.info().lhs) && (info().exponent == other.info().exponent);
        } else if (type == Type::Row) {
            return (info().lhs == other.info().lhs) && (info().block.startRow == other.info().block.startRow);
        } else if (type == Type::Column) {
            return (info().lhs == other.info().lhs) && (info().block.startCol == other.info().block.startCol);
        } else if (type == Type::Element) {
            return (info().lhs == other.info().lhs) && (info().block.startRow == other.info().block.startRow) && (info().block.startCol == other.info().block.startCol);
        } else if (type == Type::Block) {
            return (info().lhs == other.info().lhs) && (info().block == other.info().block);
        } else if (type == Type::Identity || type == Type::Null) {
            return (rows() == other.rows()) && (cols() == other.cols());
        }
    }


    return false;
}

template <class EvaluableT>
template <typename EvaluableRhs>
bool levi::ExpressionComponent<EvaluableT>::operator!=(const levi::ExpressionComponent<EvaluableRhs>& other) const {
    assert(m_evaluable && "This expression is empty.");
    assert(other.isValidExpression() && "The other expression is empty.");

    return !operator==(other);
}

template<class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<typename EvaluableT::value_type> > levi::ExpressionComponent<EvaluableT>::pow(typename EvaluableT::value_type exponent) const
{
    static_assert ((EvaluableT::rows_at_compile_time == Eigen::Dynamic || EvaluableT::rows_at_compile_time == 1) && (EvaluableT::cols_at_compile_time == Eigen::Dynamic || EvaluableT::cols_at_compile_time == 1),
                   "pow can be used only with scalars or 1x1 matrices.");
    assert(rows() == 1 && cols() == 1 && "pow can be used only with scalars or 1x1 matrices.");
    return ExpressionComponent<levi::PowEvaluable<EvaluableT>>(*this, exponent);
}

template <class EvaluableT>
template<class EvaluableRhs, typename>
void levi::ExpressionComponent<EvaluableT>::operator=(const levi::ExpressionComponent<EvaluableRhs>& rhs) {
    static_assert (!std::is_base_of<levi::VariableBase, EvaluableT>::value, "Cannot assign an expression to a variable." );
    m_isNull = rhs.m_isNull;
    m_isIdentity = rhs.m_isIdentity;

    if (m_evaluable) {
        m_evaluable->deleteID(m_callerID);
    }

    if (rhs.isValidExpression()) {
        casted_assignement(levi::bool_value<std::is_base_of<EvaluableT, EvaluableRhs>::value>(), rhs);
    }
}

template <class EvaluableT>
void levi::ExpressionComponent<EvaluableT>::operator=(const levi::ExpressionComponent<EvaluableT>& rhs) {
    m_isNull = rhs.m_isNull;
    m_isIdentity = rhs.m_isIdentity;
    if (m_evaluable) {
        m_evaluable->deleteID(m_callerID);
    }

    m_evaluable = rhs.m_evaluable;
    if (m_evaluable) {
        m_callerID = m_evaluable->getNewCallerID();
    }
}

template <class EvaluableT>
template<class EvaluableRhs, typename>
void levi::ExpressionComponent<EvaluableT>::operator=(const levi::ExpressionComponent<EvaluableRhs>&& rhs) {
    static_assert (!std::is_base_of<levi::VariableBase, EvaluableT>::value, "Cannot assign an expression to a variable." );
    m_isNull = rhs.m_isNull;
    m_isIdentity = rhs.m_isIdentity;
    if (m_evaluable) {
        m_evaluable->deleteID(m_callerID);
    }

    if (rhs.isValidExpression()) {
        casted_assignement(levi::bool_value<std::is_base_of<EvaluableT, EvaluableRhs>::value>(), rhs);
    }
}

template <class EvaluableT>
void levi::ExpressionComponent<EvaluableT>::operator=(const levi::ExpressionComponent<EvaluableT>&& rhs) {
    m_isNull = rhs.m_isNull;
    m_isIdentity = rhs.m_isIdentity;

    if (m_evaluable) {
        m_evaluable->deleteID(m_callerID);
    }

    m_evaluable = rhs.m_evaluable;
    if (m_evaluable) {
        m_callerID = m_evaluable->getNewCallerID();
    }
}

//assign from a constant
template <class EvaluableT>
template<typename Matrix>
void levi::ExpressionComponent<EvaluableT>::operator=(const Matrix& rhs) {
    static_assert (std::is_base_of<levi::Assignable<typename EvaluableT::matrix_type>, EvaluableT>::value ||
                      std::is_base_of<levi::EvaluableVariable<typename EvaluableT::matrix_type>, EvaluableT>::value, "This expression cannot be set equal to a constant.");
    assert(m_evaluable && "This expression cannot be set because the constructor was not called properly.");
    std::static_pointer_cast<typename std::conditional<std::is_base_of<levi::Assignable<typename EvaluableT::matrix_type>, EvaluableT>::value,
                                              levi::Assignable<typename EvaluableT::matrix_type>,
                                              levi::EvaluableVariable<typename EvaluableT::matrix_type>>::type>(m_evaluable)->operator=(rhs);
}

template <class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<typename EvaluableT::row_type>> levi::ExpressionComponent<EvaluableT>::row(Eigen::Index row) const {
    assert(row < this->rows());
    assert(m_evaluable && "Cannot extract a row from this expression");

    if (rows() == 1) {
        return return_this<levi::Evaluable<typename EvaluableT::row_type>>(levi::bool_value<(EvaluableT::rows_at_compile_time == 1) || (EvaluableT::rows_at_compile_time == Eigen::Dynamic)>());
    }

    levi::ExpressionComponent<levi::Evaluable<typename EvaluableT::row_type>> rowExpr =
        m_evaluable->row(row);

    if(rowExpr.isValidExpression()) {
        return rowExpr;
    }

    return levi::ExpressionComponent<levi::RowEvaluable<EvaluableT>>(*this, row);
}

template <class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<typename EvaluableT::col_type>> levi::ExpressionComponent<EvaluableT>::col(Eigen::Index col) const {
    assert(col < this->cols());
    assert(m_evaluable && "Cannot extract a column from this expression");

    if (cols() == 1) {
        return return_this<levi::Evaluable<typename EvaluableT::col_type>>(levi::bool_value<(EvaluableT::cols_at_compile_time == 1) || (EvaluableT::cols_at_compile_time == Eigen::Dynamic)>());
    }

    levi::ExpressionComponent<levi::Evaluable<typename EvaluableT::col_type>> colExpr =
        m_evaluable->col(col);

    if(colExpr.isValidExpression()) {
        return colExpr;
    }

    return levi::ExpressionComponent<levi::ColEvaluable<EvaluableT>>(*this, col);
}

template<class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<typename EvaluableT::value_type>> levi::ExpressionComponent<EvaluableT>::operator()(Eigen::Index row, Eigen::Index col) const
{
    assert(row < this->rows());
    assert(col < this->cols());
    assert(m_evaluable && "Cannot extract an element from this expression");

    if (cols() == 1 && rows() == 1) {
        return return_this<levi::Evaluable<typename EvaluableT::value_type>>(levi::bool_value<((EvaluableT::rows_at_compile_time == 1) || (EvaluableT::rows_at_compile_time == Eigen::Dynamic)) &&
                                                                             ((EvaluableT::cols_at_compile_time == 1) || (EvaluableT::cols_at_compile_time == Eigen::Dynamic))>());
    }

    levi::ExpressionComponent<levi::Evaluable<typename EvaluableT::value_type>> element =
        m_evaluable->element(row, col);

    if(element.isValidExpression()) {
        return element;
    }

    return levi::ExpressionComponent<levi::ElementEvaluable<EvaluableT>> (*this, row, col);
}

template<class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<typename levi::dynamic_block_return<typename EvaluableT::matrix_type>::type>> levi::ExpressionComponent<EvaluableT>::block(Eigen::Index startRow, Eigen::Index startCol, Eigen::Index numberOfRows, Eigen::Index numberOfCols) const
{
    assert(m_evaluable && "Cannot extract a block from this expression");
    assert(((startRow + numberOfRows) <= rows()) && ((startCol + numberOfCols) <= cols()) && "Invalid block settings.");

    if (m_isNull) {
        return levi::ExpressionComponent<levi::NullEvaluable<typename levi::dynamic_block_return<typename EvaluableT::matrix_type>::type>>(numberOfRows, numberOfCols);
    }

    return levi::ExpressionComponent<levi::BlockEvaluable<EvaluableT, levi::Evaluable<typename levi::dynamic_block_return<typename EvaluableT::matrix_type>::type>>>(*this, startRow, startCol, numberOfRows, numberOfCols);
}

template<class EvaluableT>
template<unsigned int numberOfRows, unsigned int numberOfCols>
levi::ExpressionComponent<levi::Evaluable<typename levi::fixed_block_return<typename EvaluableT::matrix_type, numberOfRows, numberOfCols>::type> > levi::ExpressionComponent<EvaluableT>::block(Eigen::Index startRow, Eigen::Index startCol) const
{
    assert(m_evaluable && "Cannot extract a block from this expression");
    assert(((startRow + numberOfRows) <= rows()) && ((startCol + numberOfCols) <= cols()) && "Invalid block settings.");

    typedef typename levi::fixed_block_return<typename EvaluableT::matrix_type, numberOfRows, numberOfCols>::type block_type;

    if (m_isNull) {
        return levi::ExpressionComponent<levi::NullEvaluable<block_type>>();
    }


    return levi::ExpressionComponent<levi::BlockEvaluable<EvaluableT, levi::Evaluable<block_type>>> (*this, startRow, startCol, numberOfRows, numberOfCols);
}

template<class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<Eigen::Matrix<typename EvaluableT::value_type, 3, 3>>> levi::ExpressionComponent<EvaluableT>::skew() const
{
    static_assert (((EvaluableT::rows_at_compile_time == Eigen::Dynamic) ||(EvaluableT::rows_at_compile_time == 3)) &&
                   ((EvaluableT::cols_at_compile_time == Eigen::Dynamic) ||(EvaluableT::cols_at_compile_time == 1)) , "Skew can be applied only to three dimensional vectors.");
    assert(m_evaluable && "Cannot compute the skew symmetric matrix from this expression.");
    assert(rows() == 3 && cols() == 1 && "skew can be applied only to three dimensional vectors.");

    return levi::ExpressionComponent<levi::SkewEvaluable<EvaluableT>>(*this, 0);
}

template<class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<Eigen::Matrix<typename EvaluableT::value_type, 3, 1>>> levi::ExpressionComponent<EvaluableT>::vee() const
{
    static_assert (((EvaluableT::rows_at_compile_time == Eigen::Dynamic) ||(EvaluableT::rows_at_compile_time == 3)) &&
                      ((EvaluableT::cols_at_compile_time == Eigen::Dynamic) ||(EvaluableT::cols_at_compile_time == 3)) , "Vee can be applied only to three dimensional squared matrices.");
    assert(m_evaluable && "Cannot apply the vee operator to this expression.");
    assert(rows() == 3 && cols() == 3 && "Vee can be applied only to three dimensional squared matrices.");

    return levi::ExpressionComponent<levi::VeeEvaluable<EvaluableT>>(*this, 0);
}

template<class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<typename levi::transpose_type<EvaluableT>::type> > levi::ExpressionComponent<EvaluableT>::transpose() const
{
    assert(m_evaluable && "Cannot compute the transpose from this expression.");

    if (rows() == 1 && cols() == 1) {
        return *this;
    }

    return levi::ExpressionComponent<levi::TransposeEvaluable<EvaluableT>>(*this, 0);
}


template<class EvaluableT>
levi::ExpressionComponent<levi::EvaluableVariable<typename EvaluableT::col_type> > levi::ExpressionComponent<EvaluableT>::asVariable() const
{
    assert(m_evaluable && "The expression is empty.");

    return levi::ExpressionComponent<levi::VariableFromExpressionEvaluable<EvaluableT>>(*this, true);
}

template<class EvaluableT>
levi::ExpressionComponent<levi::EvaluableVariable<typename EvaluableT::col_type> > levi::ExpressionComponent<EvaluableT>::asIndependentVariable() const
{
    assert(m_evaluable && "The expression is empty.");

    return levi::ExpressionComponent<levi::VariableFromExpressionEvaluable<EvaluableT>>(*this, false);
}

template<class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<Eigen::Matrix<typename EvaluableT::value_type, Eigen::Dynamic, Eigen::Dynamic>>>
levi::ExpressionComponent<EvaluableT>::squeeze(const std::string& name) const {
    assert(m_evaluable && "Cannot squeeze this expression. It is empty.");

    return levi::ExpressionComponent<levi::SqueezeEvaluable<EvaluableT>>(*this, name);
}

template<class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<Eigen::Matrix<typename EvaluableT::value_type, Eigen::Dynamic, Eigen::Dynamic>>>
levi::ExpressionComponent<EvaluableT>::compile(const std::string& name) const {
    assert(m_evaluable && "Cannot squeeze compile expression. It is empty.");

    return levi::ExpressionComponent<levi::AutogeneratedEvaluable<EvaluableT>>(*this, name);
}

template<typename EvaluableT>
template<typename VariableType>
levi::ExpressionComponent<typename EvaluableT::derivative_evaluable> levi::ExpressionComponent<EvaluableT>::getColumnDerivative(Eigen::Index column,
                                                                                                                                const levi::ExpressionComponent<levi::EvaluableVariable<VariableType>> &variable) const
{
    assert(m_evaluable && "Cannot compute the derivative of this expression.");
    assert(column < cols());
    assert(variable.m_evaluable && "Invalid variable.");

    return m_evaluable->getColumnDerivative(column, variable.m_evaluable);
}

template<typename EvaluableT>
levi::ExpressionComponent<typename EvaluableT::derivative_evaluable> levi::ExpressionComponent<EvaluableT>::getColumnDerivative(Eigen::Index column, std::shared_ptr<levi::VariableBase> variable) const
{
    assert(m_evaluable && "Cannot compute the derivative of this expression.");
    assert(column < cols());
    assert(variable && "Empty variable pointer.");

    return m_evaluable->getColumnDerivative(column, variable);
}

template<class EvaluableT>
void levi::ExpressionComponent<EvaluableT>::clearDerivativesCache()
{
    if (m_evaluable) {
        m_evaluable->clearDerivativesCache();
    }
}

template<typename EvaluableT>
template<typename VariableType>
bool levi::ExpressionComponent<EvaluableT>::isDependentFrom(const levi::ExpressionComponent<levi::EvaluableVariable<VariableType>> &variable) const
{
    assert(m_evaluable && "Cannot compute the derivative of this expression.");
    assert(variable.m_evaluable && "Invalid variable.");

    return m_evaluable->isDependentFrom(variable.m_evaluable);
}

template<typename EvaluableT>
bool levi::ExpressionComponent<EvaluableT>::isDependentFrom(std::shared_ptr<levi::VariableBase> variable) const
{
    assert(m_evaluable && "Cannot compute the derivative of this expression.");
    assert(variable && "Empty variable pointer.");

    return m_evaluable->isDependentFrom(variable);
}

template<typename EvaluableT>
std::vector<levi::Registrar*> levi::ExpressionComponent<EvaluableT>::getDependencies() const
{
    assert(m_evaluable && "Cannot get the dependencies of this expression.");
    return m_evaluable->getDependencies();
}

template<class EvaluableT>
bool levi::ExpressionComponent<EvaluableT>::isValidExpression() const
{
    return m_evaluable.use_count();
}

template<class EvaluableT>
levi::ExpressionComponent<EvaluableT> levi::ExpressionComponent<EvaluableT>::ComposeByRows(const std::vector<levi::ExpressionComponent<levi::Evaluable<typename EvaluableT::row_type>>> &rows, std::string name)
{
    return levi::ExpressionComponent<levi::ConstructorByRows<levi::Evaluable<typename EvaluableT::row_type>, EvaluableT::rows_at_compile_time>>(rows, name);
}

template<class EvaluableT>
levi::ExpressionComponent<EvaluableT> levi::ExpressionComponent<EvaluableT>::ComposeByCols(const std::vector<levi::ExpressionComponent<levi::Evaluable<typename EvaluableT::col_type>>> &cols, std::string name)
{
    return levi::ExpressionComponent<levi::ConstructorByCols<levi::Evaluable<typename EvaluableT::col_type>, EvaluableT::cols_at_compile_time>>(cols, name);
}

template<class EvaluableT>
template <typename LeftEvaluable, typename RightEvaluable>
levi::ExpressionComponent<EvaluableT> levi::ExpressionComponent<EvaluableT>::Horzcat(const levi::ExpressionComponent<LeftEvaluable>& lhs,
                                                                                     const levi::ExpressionComponent<RightEvaluable>& rhs,
                                                                                     const std::string &name) {
    static_assert(typename LeftEvaluable::value_type() == typename RightEvaluable::value_type(), "You are mixing matrices of different types.");
    static_assert ((LeftEvaluable::rows_at_compile_time == RightEvaluable::rows_at_compile_time) ||
                      (LeftEvaluable::rows_at_compile_time * RightEvaluable::rows_at_compile_time < 0), "The two evaluables have different number of columns");
    assert(lhs.rows() == rhs.rows() && "The two evaluables have different number of columns");
    return levi::ExpressionComponent<levi::HorzcatEvaluable<EvaluableT, LeftEvaluable, RightEvaluable>>(lhs, rhs, name);
}

template<class EvaluableT>
template <typename TopEvaluable, typename BottomEvaluable>
levi::ExpressionComponent<EvaluableT> levi::ExpressionComponent<EvaluableT>::Vertcat(const levi::ExpressionComponent<TopEvaluable>& top,
                                                                                     const levi::ExpressionComponent<BottomEvaluable>& bottom,
                                                                                     const std::string& name) {
    static_assert(typename TopEvaluable::value_type() == typename BottomEvaluable::value_type(), "You are mixing matrices of different types.");
    static_assert ((TopEvaluable::cols_at_compile_time == BottomEvaluable::cols_at_compile_time) ||
                      (TopEvaluable::cols_at_compile_time * BottomEvaluable::cols_at_compile_time < 0), "The two evaluables have different number of columns");
    assert(top.cols() == bottom.cols() && "The two evaluables have different number of columns");
    return levi::ExpressionComponent<levi::VertcatEvaluable<EvaluableT, TopEvaluable, BottomEvaluable>>(top, bottom, name);
}

//end of ExpressionComponent implementation

template <typename Matrix, class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<typename levi::matrix_sum_return<typename EvaluableT::matrix_type, Matrix>::type>> operator+(const Matrix& lhs, const levi::ExpressionComponent<EvaluableT> &rhs) {

    levi::ExpressionComponent<levi::ConstantEvaluable<Matrix>> constant =
            levi::build_constant(levi::bool_value<std::is_arithmetic<Matrix>::value>(), lhs);

    return constant + rhs;
}

template <typename Matrix, class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<typename levi::matrix_sum_return<typename EvaluableT::matrix_type, Matrix>::type>> operator-(const Matrix& lhs, const levi::ExpressionComponent<EvaluableT> &rhs) {

    levi::ExpressionComponent<levi::ConstantEvaluable<Matrix>> constant =
            levi::build_constant(levi::bool_value<std::is_arithmetic<Matrix>::value>(), lhs);

    return constant - rhs;
}

template <typename Matrix, class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<typename levi::matrix_product_return<Matrix, typename EvaluableT::matrix_type>::type>> operator*(const Matrix& lhs, const levi::ExpressionComponent<EvaluableT> &rhs) {

    levi::ExpressionComponent<levi::ConstantEvaluable<Matrix>> newConstant =
            levi::build_constant<Matrix>(levi::bool_value<std::is_arithmetic<Matrix>::value>(), lhs);

    return newConstant * rhs;
}

template <typename Matrix, class EvaluableT>
levi::ExpressionComponent<levi::Evaluable<typename levi::matrix_product_return<Matrix, typename EvaluableT::value_type>::type>> operator/(const Matrix& lhs, const levi::ExpressionComponent<EvaluableT> &rhs) {

    levi::ExpressionComponent<levi::ConstantEvaluable<Matrix>> newConstant =
            levi::build_constant<Matrix>(levi::bool_value<std::is_arithmetic<Matrix>::value>(), lhs);

    return newConstant / rhs;
}

#endif // LEVI_EXPRESSIONIMPLEMENTATION_H
