/*
* Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
* Authors: Stefano Dafarra
* CopyPolicy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
*
*/
#ifndef LEVI_MULTIPLECOMPILEDEXPRESSIONS_H
#define LEVI_MULTIPLECOMPILEDEXPRESSIONS_H

#include <levi/ForwardDeclarations.h>
#include <levi/HelpersForwardDeclarations.h>
#include <levi/AutogeneratedHelper.h>
#include <levi/CompiledEvaluable.h>


template <typename EvaluableT>
class levi::MultipleCompiledExpressions {
public:

    typedef std::pair<std::string, levi::ExpressionComponent<EvaluableT>> CompiledElement;
    typedef std::unordered_map<std::string, typename EvaluableT::matrix_type> OutputType;
    typedef std::unordered_map<std::string, levi::ExpressionComponent<EvaluableT>> InputType;

private:

    using SqueezedMatrix = typename levi::TreeComponent<EvaluableT>::SqueezedMatrix;
    using SqueezedMatrixRef = Eigen::Ref<SqueezedMatrix>;
    using base_type = levi::CompiledEvaluable<SqueezedMatrixRef, std::vector<SqueezedMatrixRef>&>;

    std::vector<CompiledElement> m_elements;
    levi::AutogeneratedHelper<EvaluableT> m_helper;
    levi::CompiledEvaluableFactory<base_type> m_compiledEvaluable;
    OutputType m_results;
    std::vector<SqueezedMatrixRef> m_resultsRef;


public:

    MultipleCompiledExpressions(const InputType& elements, const std::string& name) {

        std::vector<levi::ExpressionComponent<EvaluableT>> expressions;

        for (auto& element: elements) {
            expressions.push_back(element.second);
            m_results[element.first] = SqueezedMatrix::Zero(expressions.back().rows(), expressions.back().cols());
            m_resultsRef.emplace_back(m_results[element.first]);
        }

        m_helper.setVariablesName("g", "h", "c");

        m_helper.setExpressions(expressions, name);

        std::string cleanName = m_helper.name();

        std::ostringstream header;
        header << "//This file has been autogenerated" << std::endl;
        header << "#ifndef LEVI_COMPILED"<< cleanName << "_H" << std::endl;
        header << "#define LEVI_COMPILED"<< cleanName << "_H" << std::endl;

        header << "#include<levi/CompiledEvaluable.h>" << std::endl << std::endl;
        header << "class " << cleanName << ": public " << type_name<base_type>() << " {" <<std::endl;
        header << "public:" << std::endl;
        header << "    virtual void evaluate(const std::vector<" << type_name<SqueezedMatrixRef>() << ">& g, std::vector<"
               << type_name<SqueezedMatrixRef>() << ">& output) final;" << std::endl;
        header << "};" << std::endl;
        header << "#endif //LEVI_COMPILED"<< cleanName << "_H" << std::endl;

        std::ostringstream cpp;
        cpp << "void " << cleanName << "::evaluate(const std::vector<" << type_name<SqueezedMatrixRef>() << ">& g, std::vector<"
            << type_name<SqueezedMatrixRef>() << ">& output) {" << std::endl;
        cpp << m_helper.getHelpersDeclaration().str() << std::endl;
        cpp << m_helper.getCommonsDeclaration().str() << std::endl;

        for (size_t i = 0; i < expressions.size(); ++i) {
            if (expressions[i].rows() == 1 && expressions[i].cols() == 1) {
                cpp << "    output[" << std::to_string(i) << "](0, 0) = ";
            } else {
                cpp << "    output[" << std::to_string(i) << "] = ";
            }
            cpp << m_helper.getFinalExpressions()[i].str() << ";" << std::endl << std::endl;
        }

        cpp << "}" << std::endl;

        m_helper.compile(header.str(), cpp.str(), m_compiledEvaluable, cleanName);
    }

    ~MultipleCompiledExpressions() { }

    const OutputType& evaluate() {

        const std::vector<SqueezedMatrixRef>& generics = m_helper.evaluateGenerics();
        m_compiledEvaluable->evaluate(generics, m_resultsRef);

        return m_results;

    }
};

#endif // LEVI_MULTIPLECOMPILEDEXPRESSIONS_H
